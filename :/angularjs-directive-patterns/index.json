{"pageType": "article", "pathParams": {"slug": "angularjs-directive-patterns"}, "locals": {"article": {"body": "<p>One of the most powerful concepts AngularJS is the <em>directive</em>. Directives\nare a key building block, allowing behavior to be assigned to HTML elements\nin a declarative way, turning the HTML DOM into a rich template language for\nresponsive, interactive applications.</p><p>Directives represent a very powerful and flexible tool, and it's often unclear\nhow best to apply this tool to various problems. This article is a collection\nof design examples that apply directives to solve particular classes of\nproblem. In the process we will explore the key features of AngularJS\ndirectives and see how these features can interact to produce positive as well\nas negative results.</p><p>This article assumes some familiarity with AngularJS concepts such as scopes,\ncontrollers and templates. If you're completely new to Angular, I suggest\nreading <a href=\"https://docs.angularjs.org/tutorial\" target=\"_blank\">the PhoneCat tutorial</a> as\na starting point, and getting some experience using pre-existing directives\nbefore attempting to build your own.</p><section id=\"directive-basics\"><h3>Directive Basics</h3><p>Before we get stuck in let's quickly recap the general principles of\ndirectives, to establish the terminology that will appear in the remainder\nof the article.</p><p>As noted above, directives allow behavior to be assigned to HTML elements.\nThis occurs during Angular's <em>template compilation</em> process, in which it\nwalks a HTML DOM tree and matches each node against the table of defined\ndirectives.</p><p>A defined directive can apply to a particular element name, a particular\nattribute name, a particular class (in the CSS sense) or to a special format\nof HTML comment. Most directives apply to element and/or attribute names,\nsince these are the most natural to use in templates.</p><p>Given the various ways directives can apply, a given DOM node can potentially\nhave several different directives applied to it. Here's a simple example\nof an HTML element with three attribute-based directives:</p><p>Each of the attributes instantiates a different directive and each directive\noperates largely independently of the others. Since they are all operating on\nthe same element, is is important that their respective concerns are\nwell-separated to avoid strange collisions in behavior.</p><section id=\"directive-instantiation-phases\"><h4>Directive Instantiation Phases</h4><p>A directive is instantiated in two distinct phases.</p><p>The directive is first given an opportunity to \"compile\" its template, and in\nthis phase it is operating on the original <em>template</em> DOM as given in the\nsource HTML document, before any scopes have been assigned.</p><p>Most directives do not make use of this compilation phase, but a key example\nof the use of this phase is the <tt>ngRepeat</tt> directive, which produces zero\nor more copies of the template element it is given. During its compile phase\nit parses the repeat expression given in its attribute value, which thus\ninforms how many copies of the element will be created.</p><p>Once directives have had an opportunity to \"compile\" they are then given the\nopportunity to \"link\". During the link phase the directive recieves its\n<em>instance element</em> and the corresponding scope, and the directive is\nresponsible for connecting these together in whichever way is appropriate.</p><p>To understand the difference between the compile and link phases, the\n<tt>ngRepeat</tt> directive is again helpful. Considering again a simple\nexample of a repeated element:</p><p>The <tt>ng-repeat</tt> attribute causes this element to be cloned potentially many\ntimes in the resulting DOM. From the perspective of the <tt>ngSrc</tt> directive,\nits <em>compilation</em> phase occurs only once, before those clones are created.\nIts <em>linking</em> phase is, on the other hand, likely to occur several times:\nonce for each clone that is created, with each link call receiving a different\ninstance element and scope.</p></section><section id=\"relationship-to-scopes-and-controllers\"><h4>Relationship To Scopes and Controllers</h4><p>Angular's concept of <em>scopes</em> is also important when working with directives.\nFundamentally a scope is just a collection of named values, possibly inheriting\nother named values from a <em>parent</em> scope.</p><p>Each scope is usually managed by a <em>controller</em>, which places data into the\nscope for use by templates as well as providing an API through which the\ntemplate, as well as other controllers, can manipulate that data.</p><p>There are many ways to create scopes in Angular, and many applications of\ncontrollers. Directives are the most common means by which scopes are created,\nand instantiating controllers for those new scopes is often a key part of the\nlink phase of a directive.</p></section></section><section id=\"simple-template-directives\"><h3>Simple Template Directives</h3><p>By far the simplest case of a directive is one that exists just as an\nabstraction over a more complex HTML template, taking arguments from\nits attributes and making them available in the template.</p><p>This is such a common case that AngularJS allows it to be implemented\nin a completely declarative way:</p><p>This can then be used as follows:</p><p>In the above template declaration, the <tt>scope</tt> property tells the compiler\nthat this directive needs its own local scope, and in turn requests that\nthe scope should be populated with a <tt>name</tt> key whose value is bound to\nthe contents of the <tt>name</tt> attribute. The <tt>@</tt> prefix on the property\nvalue indicates that we wish to interpret the attribute value as an\ninterpolated string, which means we can also use interpolation syntax if\nrequired:</p><p>In terms of the directive phases described earlier, the Angular compiler\nis effectively providing a default compile and link phase for this kind\nof directive. In the compile phase, the provided template is recursively\npassed back into the compiler for processing. The link phase can then just\nlink the new scope to the compiled template, producing the desired result.</p><p>This simple usage of directives is only a small step above the built-in\n<tt>ngInclude</tt> directive. The difference is that our custom directive can\ntake data from custom element attributes rather than only from values\nalready present in the parent scope, creating a small layer of abstraction\nbetween the templates.</p><p>Simple template directives are a great way to make reusable, self-contained\nbundles of markup that can be called on many times in your application.</p></section><section id=\"template-wrappers\"><h3>Template Wrappers</h3><p>A small extension of the simple template case is a template that <em>wraps</em>\nsome other caller-provided content. Consider for example a reusable modal\ndialog directive:</p><p>Since this template is longer than the previous one we'll keep it in a\nseparate file and reference it by URL. Here's the contents of the template\nfile:</p><p>First notice that in the <tt>scope</tt> property in the declaration we're now using\nthe <tt>&amp;</tt> prefix instead of the <tt>@</tt> used previously. This requests that\nthe given attribute be parsed as an <em>expression</em>, and the scope populated not\nwith the result of the expression but instead a <em>function</em> that can be called\nto evaluate the expression. This allows the caller to provide an event handler\nthat will be called on close, as we'll see in a moment.</p><p>The other point of note here is the use of the <tt>transclude</tt> property on\nthe directive declaration, along with the <tt>ng-transclude</tt> attribute within\nthe template. The former requests that the entire contents of the directive's\ntemplate element be compiled and saved, while the latter causes the saved\ncontents to be recalled and inserted as the contents of the annotated\nelement.</p><p>With this all in place, we can make use of our modal dialog like this:</p><p>Here we assume that a parent controller has provided this <tt>dialogResult</tt>\nfunction in the scope. Its implementation is left as an exercise for the\nreader, but the result of this template will be an instance of the modal\ndialog template from above, with the provided question and buttons embedded in\nits content element. When the \"close\" widget on the modal is clicked, it will\nhave the same effect as clicking the cancel button due to the use of the same\nevent-handler for both.</p></section><section id=\"event-handling-directives\"><h3>Event-handling Directives</h3><p>In the previous example we saw how a directive can provide an event-handling\ninterface in addition to its other behavior. In the interests of separating\nconcerns though, it's often useful to have directives whose only purpose is\nto detect events and signal them via expressions.</p><p>The built-in <tt>ngClick</tt>, <tt>ngBlur</tt> etc directives are examples of this in\nthe standard library. Implementing an event-handling directive makes a good\nfirst example of a directive with custom compile and link phases, as opposed\nto providing a template and using the built-in functionality.</p><p>Let's consider the example of a directive that signals an event if the\nmouse pointer hovers over an element for three seconds. This is a contrived\nexample but simple enough not to distract too much from the mechanism.</p><p>Unlike our previous examples, we do not specify the <tt>scope</tt> or <tt>template</tt>\nproperties here. Only one directive on each element can use <tt>scope</tt>, so it\nis good manners to avoid its use on small directives intended for use in\nconjunction with others. We also want to have no visual effect on the document,\nso the use of <tt>template</tt> would be inappropriate here.</p><p>Instead, we manually implement the compile and link phases of our directive.\nIn our compile phase, we make use of the <tt>$parse</tt> service, which is where\nAngular's expression parse is implemented. It takes a string containing\nan expression like <tt>\"beginTakeover()\"</tt>, and returns a function that takes\na scope and returns the result of evaluating the expression in that scope.</p><p>The compile function ends by returning the link function. In the link function\nit's time to bind our behavior to the DOM, in this case by registering some\nDOM event handlers on our instance element <tt>iElement</tt>.</p><p>When the hover condition is eventually detected through the successful\ncompletion of our timeout, we finally call the function we obtained during\nthe compile phase, passing in the related scope.</p><p>Since we set <tt>restrict</tt> to <tt>'A'</tt> in our declaration, this directive is\nvalid only as an attribute. Where we left this unstated in the previous\nexamples it defaulted to applying to both elements <em>and</em> attributes.</p><p>With all of that in place, it is a simple matter to use this directive:</p><p>Assuming some CSS is provided to make this element big enough to hover the\nmouse over, the <tt>beginTakeover</tt> function in the current scope will be\ncalled after the mouse dwells for three seconds, as we intended.</p><p>Recall that earlier we noted that there may be many calls to the link function\nfor each call to the compile function. That is true here, for example if we\nwere to combine <tt>ng-repeat</tt> with <tt>on-dwell</tt>:</p><p>In the above scenario, the directive's compile function will be called <em>once</em>,\nbeing passed in the single element that resulted from parsing the above\nHTML snippet. However, the returned link function will be <em>for each object</em> in\nthe <tt>ads</tt> collection, and will be passed instead the <em>cloned</em>\nelement that <tt>ng-repeat</tt> created, along with a child scope that contains one\nof the ads in the <tt>ad</tt> variable, causing <tt>ad.beginTakeover()</tt> to be called\nwith the correct object for each element.</p><p>To keep distinct the concepts of the <em>template element</em> passed into compile\nand the <em>instance element</em> passed into link, it is conventional to name these\n and  respectively.</p></section><section id=\"directives-with-controllers\"><h3>Directives With Controllers</h3><p>In our earliest examples we saw how a directive can be used just as a simple\ncontainer for encapsulating a template. Sometimes a static template is not\nenough however, and a controller is desired to bring some behavior into play.</p><p>The following is a declaration of a simple \"image carousel\" directive, which\ntakes an array of image URLs and shows them one at a time, with buttons\nprovided to navigate to the previous and next images.</p><p>Here the caller provides, via the <tt>image-urls</tt> attribute, an expression that\nevaluates to an array of strings containing image URLs. Our controller\nis responsible for selecting an appropriate current image URL. The selection\ncan potentially change whenever the list of images changes (e.g. if there are\nnow fewer items in the list) or when the user clicks on one of the navigation\nbuttons. Angular also helpfully calls our <tt>$watchCollection</tt> callback once\nafter first registration, triggering us to call <tt>update</tt> for the first time\nto initialize.</p><p>Here is the directive's template:</p><p>This combination of a scope, a template and a controller makes it easy to\nencapsulate a re-usable interactive visual component, with the caller just\nproviding the data.</p><section id=\"on-directives-that-load-data\"><h4>On Directives that Load Data</h4><p>Some developers are tempted to use directive controllers to load data from\nsome data source and then display it. In most cases this is not advisable since\nit mixes the concern of loading the data with the concern of displaying it.\nIt's better to at least separate the data loading into a <em>separate</em> controller,\nwhich can then be used via the <tt>ngController</tt> directive:</p><p>Better still, if your app is using a router it's often best to have the\n<em>route</em> controller be responsible for data loading, and limit the templates\nto just displaying data from the route's scope. This way the templates are\ncompletely unaware of where the data comes from.</p></section></section><section id=\"multiple-directives-on-one-element\"><h3>Multiple Directives on One Element</h3><p>As we saw earlier, it's easy to combine multiple isolated directives on a\nsingle element as long as their functionality doesn't conflict. Sometimes,\nhowever, it is desirable for one directive to interact with another, with\none directive providing a public API that can be consumed by another.</p><p>By far the most common use of this is in implementing custom form controls\nusing <tt>ngModel</tt>. All of the form control handling in AngularJS is implemented\nby applying a specific UI element directive (the <em>view</em>) to the same element\nas the <tt>ngModel</tt> directive, with the latter providing an API to the former.</p><p>Let's see how that looks from the perspective of the UI element directive,\nby implementing a simple radio-button-based boolean form element.</p><p>This is slightly different from our earlier examples in that this directive\nprovides a <em>link</em> implementation but just uses the default <em>compile</em>\nimplementation, since no processing of the template element is required.\nIn this case Angular behaves as if we had a compile function that simply\nimmediately returned the given link function.</p><p>The main new feature here is the <tt>require</tt> property in the definition. This\ntells Angular that if there is also an <tt>ngModel</tt> instance connected to this\ndirective, then provide its controller as an extra parameter to the link\nfunction. The question mark at the beginning indicates that this is an\noptional dependency, so the link function will recieve <tt>null</tt> if there\nis no <tt>ngModel</tt> present.</p><p>A full description of the functionality of <tt>ngModel</tt> is best left for an\narticle of its own, but suffice it to say that it's purpose is to allow a\nseparation between the value stored in the scope -- that is, the model value --\nfrom the form of the value used for presentation to the user. Between the\ntwo can be arbitrary transformations and validation steps.</p><p>In the above example, our interaction with the model is modest: we just\ntranslate between the boolean we store as the view model and the string\nwe receive from the primitive form elements in the template. Here is the\ntemplate, incidentally:</p><p>For convenience we're also using separate instances of <tt>ngModel</tt> on our\ninternal radio buttons, but of course these instances are distinct from\nthe one applied directly to our <tt>yesNoPicker</tt> element.</p><p>When this element is used in the template it must be used alongside <tt>ngModel</tt>\nin order to instantiate the controller we expect:</p><p>This technique allows us to <em>consume</em> the API provided by another directive\non the same element. In the next section, we'll see how such an API can be\nprovided.</p></section><section id=\"interacting-with-a-parent-directive\"><h3>Interacting with a Parent Directive</h3><p>Sometimes it is necessary to build a template construct that is too complex\nto be declared with only one element. Constructs like <tt>ngSwitch</tt> require\nboth a container element that establishes a context and then zero or more\nchild elements that complete the definition.</p><p>These multi-element constructs can be implemented using the same <tt>require</tt>\nmechanism we saw in the previous section. To demonstrate, let's build a\ndirective that provides an easy way to create an HTML table from a list\nof objects.</p><p>In this case we will actually need <em>two</em> directives: one to establish the\ntable container, and the other to declare the individual columns.</p><p>This example brings together many features we've visited in earlier examples.\nThe <tt>autoTable</tt> directive is just like our image carousel example where\na template is combined with a controller, but this time the controller\nalso provides the <tt>registerColumn</tt> method as its public API.</p><p>The <tt>col</tt> directive declares that it requires the <tt>autoTable</tt> directive,\nbut this time it uses the <tt>?^</tt> prefix to indicate that this directive is\nrequired on the <em>parent</em> element. Again we declare it as optional, this time\nso that we don't interfere with the normal use of the <tt>col</tt> element in\na plain HTML table.</p><p>Earlier we used <tt>$parse</tt> to process AngularJS expressions, while in this\nexample we used <tt>$interpolate</tt> to process a string that may contain\ntemplate interpolation syntax, like <tt>'Hello {{ name }}!'</tt>. Its result\nis the same: a function that takes a scope (or scope-like object) and returns\nthe string result.</p><p>Here, as usual, is the template for the <tt>autoTable</tt> directive:</p><p>The <tt>col</tt> directive does not need a template because it is used only to\nprovide data to the <tt>autoTable</tt> directive and it will be removed from the\nDOM once the template is initialized.</p><p>This pair of directives can then be used together as follows:</p><p>This then expects a <tt>users</tt> array looking like this:</p><p>It is a rare situation that requires a multi-directive construct like this,\nbut when the need arises Angular's template system still provides for a\nclean separation of concerns between the different components by allowing\neach directive to provide a public API.</p></section><section id=\"conclusion\"><h3>Conclusion</h3><p>Throughout this article we have seen that directives are a very flexible\nmechanism that can be employed to solve several different classes of problem.\nFundamentally all of these different techniques can be implemented in terms\nof the low-level ability to define a custom compilation function, but\nAngular provides several shortcuts to simplify the most common cases of\ncustom directives.</p><p>The examples in this article are intended to show some different ways the\ndirective features can be combined to solve real-world problems. In summary,\nthe features we've discussed are:</p><ul><li><p><strong>Directive-specific scopes</strong> with bindings to the parent scope via HTML\nattribute values, allowing data to be passed in from a parent directive.</p></li><li><p><strong>Directive-specific controller APIs</strong>, allowing data to be passed in from\na child or sibling directive.</p></li><li><p><strong>Custom compilation and linking functions</strong>,\nallowing for arbitrary interactions with both the template and instance\nDOM elements.</p></li><li><p><strong>Child content transclusion</strong>, allowing a directive to wrap arbitrary child\ncontent inside additional template HTML.</p></li></ul><p>These building blocks together add up to support all of the varied\nfunctionality in Angular's standard directive library, as well as supporting\nyour application's specialized DOM-manipulation needs.</p><p>For an example of a novel use of directives, see my other article\non <a href=\"/angularjs-view-specific-sidebars/\">view-specific sidebars</a>, which\nshows how directives can be used to move elements out of their original\ndeclaration context and into other parts of the document, such as the\n<tt>head</tt> element or an application's sidebars.</p><p>Directives are easily the most powerful feature of AngularJS, but also arguably\nthe most misunderstood. I hope this article has shed some light on the various\ncapabilities of directives and how they can be applied to produce a modular,\nmaintainable application, or a useful reusable utility library.</p></section>", "mainImageUrl": "/angularjs-directive-patterns/None", "title": "Design Patterns with AngularJS Directives", "url": "/angularjs-directive-patterns/", "summary": "Examples of different ways AngularJS directives can be used to design effective application views", "date": "2014-09-20", "type": "AngularJS"}}, "path": "/:slug/"}