{"pageType": "article", "pathParams": {"slug": "memory-management-dependency-injection"}, "locals": {"article": {"body": "<p>Allocation of dynamic memory in memory-constrained environments is known to be\na hard problem. When memory can be allocated at runtime the following problems\npresent themselves in a fully-generalized system:</p><ul><li><p>Provision of sufficient memory: the heap must be at least as big as the\npeak dynamic memory usage of the program, but that is impossible to predict\nfor programs that allocate memory based on conditions that do not arise until\nruntime. Heap exhaustion can lead to unexpected program failure at allocation\ntime.</p></li><li><p>Fragmentation of memory: a sub-problem of provision of sufficient memory,\narising when repeated allocation and de-allocation of small memory segments\ncause available memory to be non-contiguous, limiting the maximum possible\nsize for a new allocation.</p></li><li><p>Garbage management: whether explicitly or automatically, dynamic memory may\nneed to be freed when no longer in use, but the definition of \"in use\" varies\nfrom program to program.</p></li><li><p>Performance overhead: dynamic memory allocation and de-allocation can take\nnon-deterministic amounts of time depending on the current structure of the\nheap. This is particularly problematic for systems with hard realtime\nperformance requirements, but even in non-realtime applications this can\nlead to degenerate performance that arises only after an application has been\nrunning for a long time.</p></li></ul><p>In modern programming environments the above concerns are often mitigated by\nsimply over-provisioning memory to the point that the problems arise only\nin unlikely edge cases. When memory is plentiful, one can often take a \"best\neffort\" approach to dynamic memory management, and when performance requirements\nare soft one can even resort to automatic memory management strategies like\na compacting garbage collector, which trade CPU time for improved use of heap\nmemory.</p><p>However, embedded systems remain problematic for the following reasons:</p><ul><li><p>Embedded systems are often very memory-constrained compared to today's\ngeneral-purpose computing hardware, with RAM capacities measured in\nkilobytes rather than gigabytes.</p></li><li><p>Embedded systems often have hard or soft realtime constraints placed\non them, even if just remaining ready to respond to external interrupts\nin a timely fashion, which make \"stopping the world\" for non-deterministic\namounts of time undesirable or impossible.</p></li><li><p>Embedded systems can sometimes run for many years without restarting\nand will often have no way to signal to the user that memory is becoming\ntight or has been exhausted. A seemingly-random memory allocation failure\nseveral months into the runtime of an embedded system could therefore be\nat least inconvenient, and possibly even catastrophic.</p></li></ul><p>For these reasons embedded software designers often choose to avoid dynamic\nmemory allocations altogether. Sometimes that is not possible, and so\ndesigners will adopt various strategies to <em>constrain</em> dynamic memory usage\nso that it is predictable, such as providing a fixed memory pool to each\nsubsystem and using fixed-sized allocations within those pools to avoid\nfragmentation.</p><p>The tools available for such memory management schemes in C and C++ are\nlimited, since both languages by default expect a single system allocator\nfrom which all callers obtain dynamic memory. Custom allocators are possible,\nbut memory allocation is a cross-cutting concern and so such allocators can\nmake it impossible to re-use third-party code that depends on the default\nallocator.</p><p>The remainder of this article describes a hypothetical alternative model\nof memory management which aims to make memory management more explicit\nwhile allowing code written by different parties to inter-operate. This\nnew scheme is best adopted as a core language feature, and is thus planned\nbe implemented as the built-in dynamic memory management strategy in my\nwork-in-progress embedded systems programming language, Alamatic.</p><section id=\"theory-of-operation\"><h3>Theory of Operation</h3><p>The scheme proposed below treats memory as a dependency to be provided\nvia the dependency injection pattern. In this pattern, resources required by\na subsystem are provided by the caller rather than being acquired directly.\nThis article therefore assumes some mechanism of passing dependencies\ninto a subsystem but does not specify one.</p><p>The scheme also aims to make ownership of memory explicit, preventing\ndynamic memory allocation from being buried inside leaf functions and\ninstead allowing all possible heap usage to be discovered by observing\nthe transfer of objects between functions. No automatic garbage\ncollection is included, but it is made explicit which subsystem is\nresponsible for freeing dynamically-allocated memory.</p><p>This scheme defines three types of dependency that may be provided to a\nsubsystem, at different levels of granularity and responsibility:</p><ul><li><p>A plain reference to an object or array of objects of a particular type:\nin this case, memory management is handled entirely by the caller and an\nalready-allocated buffer is provided. In C this would just be a pointer,\nand is the simplest case. A subsystem accepting a plain reference may of\ncourse be provided a reference to a static- or stack-allocated object\ninstead; allocation is a separated concern in this case.</p></li><li><p><tt>Allocation</tt> object: represents ownership of an allocated,\nstrongly-typed area of memory. This is a generic type and will be\nhenceforth referred to via the C++-style notation <tt>Allocation&lt;T&gt;</tt>.\nThis object provides the mechanism to free the allocation, and passing\nthis object as a function parameter implies transfer of ownership of the\nallocation, and with it the responsibility to free the object.</p></li><li><p><tt>MemoryPool</tt> object: represents ownership of an area of memory from\nwhich allocations can be made. This object provides the mechanism to\nacquire <tt>Allocation&lt;T&gt;</tt> objects, and also provides a mechanism to\nsub-divide the area into nested <tt>MemoryPool</tt> objects to partition\nthe memory space.</p></li></ul><p>Each of the above dependency types represents a different memory management\ncapability. By following the dependency graph a system maintainer can\ntrack all places where dynamic memory may be allocated or freed, and\nthe <tt>MemoryPool</tt> mechanism allows subdivision of the heap into a fixed\nmemory map where desired.</p></section>", "mainImageUrl": "/memory-management-dependency-injection/None", "title": "Memory Management via Dependency Injection", "url": "/memory-management-dependency-injection/", "summary": "Applying the Dependency Injection pattern for dynamic memory management in embedded systems.", "date": "2014-08-10", "type": "Programming Language Design"}}, "path": "/:slug/"}