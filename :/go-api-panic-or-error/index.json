{"pageType": "article", "pathParams": {"slug": "go-api-panic-or-error"}, "locals": {"article": {"body": "<p>Go is often characterized as a \"small\" language, with a carefully curated\n<em>minimal</em> set of features that together allow for effective programming in\nthe large. In particular, in most cases there is only one way to solve a\nparticular problem \u2014 whether enforced by the language itself or by community\nnorms \u2014 and so Go code in one project will tend to be very similar to Go code\nin another project.</p><p>To a newcomer, it can appear that error handling is an exception to this rule:\nGo seems to provide two different error-handling mechanisms, strongly encourage\nthe use of one, but yet frequently use the other. These two mechanisms are\nexplicitly returning error values (the most common and recommended approach)\nand the so-called \"panic\", which urgently aborts the running program, unwinding\nthe stack in a similar way to structured exception handling in other languages.</p><p>While the use of <tt>panic</tt> is clearly discouraged in various documentation,\nit is also frequently used in real-world Go libraries and within the standard\nlibrary itself. This gives the impression that the situation is not as\nstraightforward as the documentation makes it appear \u2014 that there are actually\nvalid reasons to use <tt>panic</tt> for error handling. The goal of this article is\nto take a pragmatic look at different ways Go libraries can and do handle\nerrors of different types, and why each may be appropriate in certain\nsituations.</p><p>This article is focused on error handling from the perspective of <em>API design</em>.\nThat is, on modeling errors in the exported API of a library to help callers of\nthat library write a program that is robust in the face of errors. Within the\nimplementation details of a library the tradeoffs are often different and the\nconsequences of a particular decision tend to fall on the library author rather\nthan on library users. Poor API design, on the other hand, is an externality\nfelt by all <em>users</em> of that API, with problems potentially repeated across\ndozens, hundreds, or thousands of other programs.</p><p>This is a subjective topic, with no absolute correct answer. You may disagree\nwith some of the tradeoffs I propose here, and that is fine: you know better\nthan I do what makes sense for your specific problem. The primary goal of this\narticle is to introduce the decisions an API designer must make, not to dictate\nthe answers to those questions.</p><section id=\"bugs-vs-errors\"><h3>Bugs vs. Errors</h3><p>Before we begin, it's worth discussing what an \"error\" actually is. There are\nlots of reasons why a program might fail to proceed as its author hoped, such\nas a required file being missing on disk, the network being misconfigured,\npower being lost on the computer where it is running, the CPU itself having\ndesign flaws...</p><p>In practice, it is folly to try to handle all possible failure modes in your\naverage program. As always, programming is a game of tradeoffs and as\nAPI designers we must weigh a number of competing concerns: Will handling this\nerror cause a significant degredation of performance in the happy path?\nCan this error be detected and handled once at the start of the program rather\nthan repeatedly during the program? Is it possible to handle this error <em>at all</em>?</p><p>The guidelines for review of library code submitted to the Go project itself\n(in standard libraries or in the \"extension\" libraries) seem at first glance\nto be very clear that <tt>panic</tt> should never be used, in the section\nsimply titled <a href=\"https://github.com/golang/go/wiki/CodeReviewComments#dont-panic\" target=\"_blank\">Don't Panic</a>:</p><blockquote><p>See <a href=\"https://golang.org/doc/effective_go.html#errors\" target=\"_blank\">https://golang.org/doc/effective_go.html#errors</a>. Don't use panic for\nnormal error handling. Use error and multiple return values.</p></blockquote><p>But the devil is in the details here. What is \"<em>normal</em> error handling\" anyway?\nIs there another <em>abnormal</em> kind of error handling? For the sake of this\narticle, I'm going to use some different terminology that I find easier to keep\nstraight in my head: <em>bugs</em> vs. <em>errors</em>.</p><p>An error, broadly speaking, is a problem that arises in the environment of the\nprogram: the program would've behaved as desired if only that important file\nhadn't been deleted, or the user's ISP weren't currently having an outage.\nInappropriate user input is another very common kind of error: users will\noften mistype command lines, use incorrect grammar in configuration files,\netc. A high-quality program will respond to errors either by working around\nthem in some way or by producing an actionable error message for the user\nof the program.</p><p>A bug, on the other hand, is a problem within the program itself. Perhaps a\ndeveloper didn't read a library's API documentation closely enough and passed\nan unacceptable argument to a function. Perhaps a particular list can\nlegitimately be empty but we forgot to handle that situation.</p><p>This binary distinction is a coarse approximation, but I think a\nhelpful one because it is approximately along this line that many of our API\ndesign decisions in the following sections will fall.</p><p>There will always be some ambiguity between errors and bugs, but we can try to\ndecide many cases by thinking about whose \"responsibility\" it is to deal with a\nparticular problem: perhaps you are writing a library that expects\nalready-validated values as input, and so you consider invalid values as a bug\nin the caller. That caller, on the other hand, may consider those invalid\nvalues to be an error caused by invalid user input. As designers of library\nAPIs we must consider carefully the scope of our library, and design its API\nso that callers can understand what is expected. Ideally, we want the compiler\nto <em>check</em> those assumptions.</p></section><section id=\"input-processing-and-output\"><h3>Input, Processing, and Output</h3><p>Another important consideration in software design is dealing with input\nand output. Many programs will begin by gathering outside data to operate on,\nand will end by emitting result data.</p><p>With \"errors\" defined as problems originating outside the program, it follows\nthat errors will be most common within these input and output phases, as it is\nthese which directly interact with the program's environment.</p><p>For example, the input phase might read a file from disk. There are lots of\nopportunities for error here: the file might not exist, the filesystem may be\ncorrupt, the file may contain data that is not in a suitable format, it may\ncontain <em>too much</em> or <em>not enough</em> data, and so on.</p><p>This leads to a general program structure as shown in the following example.</p><p>In this ideal situation, the developer of <tt>loader</tt> has guaranteed in its\nAPI documentation that the <tt>data</tt> return value will be valid and complete\nas long as the returned error is <tt>nil</tt>.</p><p>This in turn allowed the developer of <tt>doer</tt> to <em>assume</em> that validity, and\nconsider it a bug in the calling program if it receives an invalid <tt>data</tt>\nvalue; it doesn't need to also return an error value. The <tt>writer</tt> too can\nperhaps assume that <tt>result</tt> is valid in some sense guaranteed by the\n<tt>doer</tt> API documentation, but it must still be prepared to handle errors when\ncreating the result file.</p><p>What if the caller instead constructs that <tt>data</tt> value directly, and makes\ninvalid such that <tt>doer.ProcessData</tt> cannot produce a result?\nThis function has no \"normal error\" channel with which to indicate that, and\nso its only recourse is to <tt>panic</tt>. However, this is clearly a bug in the\ncalling program: <tt>doer.ProcessData</tt> mentioned in its documentation that it\nrequires data in the form produced by <tt>loader.LoadDataFile</tt>, and so\nconstructing that object some other way is incorrect usage, regardless of\nwhat environment the program is running in.</p><p>As API designers we can help callers write correct programs by making careful\nuse of the type system so that the compiler can detect some kinds of\nincorrect usage:</p><p>Depending on how <tt>doer.Data</tt> is specified, it may still be <em>possible</em> for\na calling program to construct an incorrect value, but our use of a specialized\ntype for the data helps the developer of the calling program to understand\nhow to correctly connect these different components.</p><p>In this situation, it is reasonable to use <tt>panic</tt> to respond to incorrect\ninput in <tt>doer.ProcessData</tt> because the only resolution to the problem is to\ncorrect the calling program, not to adjust the program's environment.\nThe decision to use <tt>panic</tt> here is a tradeoff: since incorrect usage of\nthis function is a bug rather than an error, we choose to carefully design the\nAPI to make this situation unlikely, which avoids placing an error-handling\nburden on correctly-implemented programs, often making the processing phase\nmore readable.</p><p>We can see this tradeoff at play within the language itself: an out-of-bounds\naccess to an array or slice is signalled via <tt>panic</tt>, rather than explicit\nerror values, because handling these errors with explicit control flow would\nrender many correct programs unreadable by introducing branches that can never\nbe visited.</p><p>This leads to a rule of thumb: always use error values when processing input\nand producing output, since normal errors are most common in these phases.\nUse <tt>panic</tt> sparingly to signal program bugs in the main processing phase,\nalong with careful API design to help callers avoid them, when the goal is to\nreduce error handling complexity in the processing phase of the calling program.</p><p>The remaining sections of this article are refinements of and guidelines for\nthis high-level rule.</p></section><section id=\"know-your-audience\"><h3>Know Your Audience</h3><p>When a problem is detected, who is expected to fix it? What does that person\nneed to know to make progress?</p><p>A <tt>panic</tt> is always directed at the developer of the calling program, and\nnever at the end-user. In the event that an end-user <em>does</em> see a panic message,\nthe user's only recourse is to contact the software developer for a corrected\nversion of the program. Because of this, the default panic behavior includes\na detailed stack trace for each active goroutine to help the developer identify\nthe precise location where the problem was detected.</p><p>Conversely, <tt>panic</tt> is never an appropriate mechanism for messaging to the\nend-user. Problems with the environment \u2014 missing files, incorrect files,\nbroken network connectivity, etc \u2014 can usually <em>not</em> be addressed by changes\nto the program, and so these problems should be reported via error values.</p><p>This often leads to a different problem: error messages at the wrong level\nof abstraction. The worst examples of this come when errors arise deep in\na call stack and intermediate functions simply pass them through, rather than\nhandling them directly. For example, consider this program that is parsing\nsome JSON input, presumably as part of a larger input-processing stage:</p><p>If the sequence of bytes given in <tt>buf</tt> is <em>not</em> valid JSON, the error\nmessage from the JSON library will be returned directly to the caller.\nIf <tt>buf</tt> is an empty byte slice, for example, the JSON parser may attempt\nto read and return <tt>io.EOF</tt> as its error.</p><p>If no other function in the call stack handles this error, it is likely to\nsurface to the end user like this:</p><pre class='terminal'>$ awesome-program\nEOF</pre><p>Not particularly helpful! The end-user may not even be aware that a file was\nbeing read and parsed as JSON here. An error return value from a function is,\nin effect, still a message to the direct caller of a function: even though it\nmay be describing a more general environmental problem, it is often doing so\nwith context and vocabulary common only between that caller and calleee.</p><p>Go's JSON library knows that its caller is trying to parse JSON, but it doesn't\nknow <em>why</em>. The caller presumably knows, and so it's the caller's responsibility\nto interpret and translate the error, re-framing the problem in a way\nthat makes sense to <em>its</em> caller, and so on until eventually the caller is the\nend user themselves.</p><p>By structuring a program or sub-program into separate input, processing, and\noutput phases, this error translation process can be simplified: the call\nstack stays relatively shallow (the \"processing\" functions are not in turn\ncalling parsers, for example) and at each phase the program is attempting to\nacheive a specific goal which can add important context to the error messages\neventually returned to the user.</p><p>However we achieve it, it's always important for our programs to produce error\nmessages that are understandable by their intended audience, with all of the\ncontext they need to understand and address the problem.</p></section><section id=\"state-your-intentions\"><h3>State Your Intentions</h3><p>As API designers, our responsibility is to design an API that is easy to use\ncorrectly. Compile-time type checks are one tool in the API designer's toolbox,\nbut are not a panacea. Go's type system is intentionally simple, and so it's\nnot possible in practice to model all real-world expectations so that they can\nbe checked by the compiler.</p><p>Another important tool in API design is <em>idiom</em>. As developers gain experience\nwith a variety of different libraries, they develop a mental model for certain\nAPI design approaches that appear repeatedly. A very important idiom in Go is\nthat of returning error values: unless otherwise stated, experienced Go\ndevelopers will expect that if a function returns a non-nil <tt>error</tt> then\nany other return values should be assumed invalid.</p><p>When an API design steps away from common idiom, developers are likely to use\nit incorrectly. Sometimes deviations from idiom are warranted though, since\neach situation is unique.</p><p>When decisions in an API design cannot be modelled as type checks and step\noutside of common idiom, API documentation is our fallback. Go has a simple\nconvention for documenting the intended contracts of functions using comments,\nwhich are rendered by the GoDoc tool.</p><p><strong>A panic is never idiomatic</strong>, and therefore intentional panic situations\nshould always be mentioned in documentation. Consider the standard <tt>reflect</tt>\npackage for example: many methods of <tt>Value</tt> use panics to signal incorrect\nusage by the caller, but crucially they all also carefully <em>document</em> the\ncorrect usage and the consequences of violating it:</p><blockquote><p><tt>Bool</tt> returns <tt>v</tt>'s underlying value. It panics if <tt>v</tt>'s kind is not <tt>Bool</tt>.</p><p><tt>Bytes</tt> returns <tt>v</tt>'s underlying value. It panics if <tt>v</tt>'s underlying value is not a slice of bytes.</p><p><tt>Interface</tt> returns <tt>v</tt>'s current value as an <tt>interface{}</tt>. It panics if the Value\nwas obtained by accessing unexported struct fields.</p></blockquote><p>With that said, I would be remiss not to mention <a href=\"http://www.hyrumslaw.com/\" target=\"_blank\">Hyrum's Law</a>:\nto mitigate this, it's best for any requirements in your documentation to be\nbacked up by specific checks in code so that correct usage can emerge from\ntrial and error as well as from careful reading of the documentation.</p></section><section id=\"help-callers-to-succeed\"><h3>Help Callers to Succeed</h3><p>When an API designer decides to consider a particular problem a bug and respond\nto it with a panic, they can improve ergonomics (and thus encourage safe\nbehavior) by providing convenient patterns of correct usage.</p><p>For example, in the previous section we saw that Go's own <tt>reflect</tt> package\nhas a number of methods that panic under incorrect usage. Some have relatively\nsimple definitions of correct usage, such as <tt>Value.Bool</tt> which works only\nfor bool values. Others are more complex, such as <tt>Value.Interface</tt> which\npanics \"if the value was obtained by accessing unexported struct fields\".</p><p>Since a particular portion of a program may not <em>know</em> how a given value was\nobtained, the package also offers <tt>Value.CanInterface</tt>, which returns true\nonly if <tt>Value.Interface</tt> could be called on the same value without a panic.</p><p>This combination of methods is optimizing for a presumed common case where\na <tt>reflect.Value</tt> is both obtained and processed within the same component,\nand thus that component can \"know\" that it obtained the value in a way that\nallows <tt>Value.Interface</tt> to succeed, but <em>allowing</em> for a less-common\nsituation where some fallback behavior or explicit error handling is needed:</p></section><section id=\"a-real-example\"><h3>A Real Example</h3><p>So far we've mainly explored hypotheticals, aside from a brief look at some\naspects of the built-in <tt>reflect</tt> library. To put these ideas in perspective,\nI'd like to use an API of my own design which attempts to navigate all of these\ntradeoffs.</p><p>My library <a href=\"https://github.com/zclconf/go-cty\" target=\"_blank\">cty</a> models types and values\nfor applications that need to deal with data that can't be statically typed\nin the host program, such as data coming from arbitrary input files (e.g. JSON)\nor whose structure is defined by a separate plugin process.</p><p>I created it in response to a sequence of bugs in another program that were\nthe result of working directly with <tt>interface{}</tt> values as their dynamic\nvalue representation, but yet expecting only a subset of values of that type.</p><p>For example, it is common for applications working with JSON to use\n<tt>encoding/json</tt> to unmarshal an arbitrary structure into an <tt>interface{}</tt>\nvalue and then use type assertions or reflection to work with that. The JSON\nlibrary is constrained to only produce a specific subset of Go types that\ncorrespond approximately with JSON's own data types, but once these values pass\ninto the larger program they may be interpreted by code with a different set\nof expectations, or may be mutated to include types that <em>cannot</em> be\nre-serialized as JSON later.</p><p><tt>cty</tt>, then, essentially establishes a subset of possible types and values\nand aims to ensure that all of the documented invariants for those types and\nvalues are preserved as the values pass through a program. Whereas passing\naround <tt>interface{}</tt> values relies on convention and good behavior, <tt>cty</tt>\nenforces correct behavior through its API.</p><p>Working with dynamic data types creates a lot more potential runtime problems,\nand raises lots of design questions around which problems are errors vs. bugs,\nand so handling of runtime problems in <tt>cty</tt> raised some interesting design\nquestions.</p><p><tt>cty</tt> follows the \"Input, Processing, and Output\" model I described in an\nearlier section.\n<a href=\"https://godoc.org/github.com/zclconf/go-cty/cty/json\" target=\"_blank\">The JSON package</a>\nwithin <tt>cty</tt> (which is separate from Go's own) is one example of both\ninput and output, converting byte buffers containing JSON syntax into\nvalues and vice-versa. The functions of this package return error values,\nand following my \"Know Your Audience\" principle <tt>Unmarshal</tt> aims to return\nerror messages that should make sense to the person who wrote the JSON input.</p><p>Once a program has obtained values of type <tt>cty.Value</tt> or <tt>cty.Type</tt>,\nthe API design switches to treating incorrect arguments as caller bugs rather\nthan errors. This optimizes for ergonomic use by correct programs that have\nperformed any necessary validation or type checking ahead of processing,\nas we can see in the following (contrived) example:</p><p>The <tt>cty.Value.AsValueSlice</tt> and <tt>cty.Value.Add</tt> methods used here are\ndesigned to assume validation was already performed during input and so will\npanic if their expectations are not met in order to reduce error-handling\n\"noise\" in the calling program. This is reflected in their documentation:</p><blockquote><p><tt>Add</tt> returns the sum of the receiver and the given other value. Both\nvalues must be numbers; this method will panic if not.</p><p><tt>AsValueSlice</tt> returns a <tt>[]cty.Value</tt> representation of a non-null,\nnon-unknown value of any type that <tt>CanIterateElements</tt>, or panics if\ncalled on any other value.</p></blockquote><p>In the latter case, we see an example of <em>helping callers to succeed</em>: the\ndefinition of what is iterable is complicated, and so <tt>cty</tt> also offers a\nmethod <tt>CanIterateElements</tt> so that a program that <em>cannot</em> assume a\nparticular type can instead succinctly detect that and handle it, avoiding the\npanic.</p><p>It is important to note that this design doesn't <em>prevent</em> a program from\npanicking. It is possible to use the library incorrectly by failing to\nguarantee the correct type before calling <tt>AsValueSlice</tt>. The design tradeoff\nhere is to provide convenient functions to ensure user input is valid early in\nthe program, allowing for more direct code (with fewer conditional branches)\nin the \"middle\" of the program, which is likely to be the most complex part of\nthe calling program and where readability is most important.</p><p>In programs like the above where the expected structure is known at compile\ntime and it is only the values that vary, <tt>cty</tt> also allows a different\napproach of converting directly to specific native Go types during the input\nphase, allowing the Go compiler to ensure correctness:</p><p>In this case we can do even more of the validation up front, and so the rest\nof the program need not worry about type-related panics at all. It may still\nhave <em>other</em> panics to worry about, of course!</p><p>The API design of <tt>cty</tt> is not perfect by any means. In practical use I've\nfound that it's easy for callers to allow null values in input but forget to\nhandle them later: this is actually true of the first <tt>cty</tt> example above \u2014\nit would panic if given <tt>[null]</tt> as input \u2014 and yet only an expert user of\nthis library would spot that bug, and it is unfortunately a case likely to be\nmissed during testing. Although it's an error on the user's part to provide\n<tt>null</tt>, it's a bug in the program that it isn't handled gracefully. (The\nsecond example actually fixes this by decoding into a Go type that cannot be\n<tt>nil</tt>, but that fix is by luck more than by care in this case.)</p></section><section id=\"do-panic\"><h3><em>Do</em> Panic?</h3><p>As we've seen in previous sections, while returning error values is the primary\nway to handle errors in a Go library, there are also some situations where a\npanic can be appropriate in conjunction with <em>other</em> design work to create an\nAPI that is ergonomic and easy to use correctly.</p><p>Through thoughtful API design, we can reduce the cognitive overhead of error\nhandling and improve readability by separating the concern of fraught\ninteractions with the environment from the more predictable business of\ncomputation.</p><p>On the other hand, mistakes in API design \u2014 as with the modelling of <tt>null</tt>\nin my library <tt>cty</tt> \u2014 can create traps where users of your library can\nreadily create incorrect programs, leading to crashes.</p><p>The decision of whether a particular problem is an error or a bug is always\ncontextual and subjective: it is one of the many tradeoffs we must make\nwhen designing the API of a library and, in a broader sense, the overall\narchitecture of a program.</p><p>The suggestions in this article can be summed up with an API design truism:\ngood API design <em>encourages</em> correct usage, through careful application of\nlanguage features, idiom, and documentation. Poor usage or over-usage of error\nvalues in an API will discourage callers from handling those errors carefully\ndue to the increase in code complexity, while poor usage of <tt>panic</tt> will lead\nto software unreliability.</p><p>I hope this article will equip the reader with a good set of questions to ask\nwhen designing APIs, and that even if you disagree with some of my conclusions\nhere \u2014 which I expect and welcome \u2014 you can do so knowingly, having considered\nall of the available options and their effects.</p></section>", "mainImageUrl": "/go-api-panic-or-error/None", "title": "Don't Panic! Handling Errors and Bugs in Go", "url": "/go-api-panic-or-error/", "summary": "Some different ways to model and handle errors and caller misbehavior in Go libraries", "date": "2018-09-08", "type": "Go"}}, "path": "/:slug/"}