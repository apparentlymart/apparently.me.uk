{"pageType": "article", "pathParams": {"slug": "angularjs-view-specific-sidebars"}, "locals": {"article": {"body": "<p>For AngularJS applications that use the standard <tt>ngRoute</tt> facility for\nnavigation between multiple pages, a common issue is that while the\n<tt>ng-view</tt> directive allows the main body of the page to vary between\nroutes, the surrounding template is frustratingly static. Even something\nas simple as updating the main page title is not supported natively.</p><p>Many applications have worked around this by having the controller manipulate\nstate -- either setting <tt>window.title</tt> directly, or writing data into\n<tt>$rootScope</tt> -- but that can often lead to presentational concerns bleeding\ninto the controller.</p><p>This article explores some techniques for allowing the view's <em>template</em> to\ninteract with the site's chrome, and thus allowing these concerns to be\nsolved in a more appropriate layer.</p><section id=\"route-specific-title\"><h3>Route-specific Title</h3><p>When navigating between views in an AngularJS application, it's desirable\nfor the HTML <tt>&lt;title&gt;</tt> element to be updated so that a user with multiple\ntabs open can quickly understand the context of each of them, or so that\na browser bookmark will recieve a sensible name.</p><p>A trivial way to accomplish this is to simply update the title in the\nroute's controller:</p><p>However, the precise formatting of the title, much as with other aspects of\nhow the content is presented to the user, is rightfully the concern of the\ntemplate layer rather than the controller layer.</p><p>What if we could express the title as part of the view's template?</p><p>AngularJS directives allow us to support additional elements in templates,\nbut this one is unusual in that it ought to have no affect on the rendering of\nthe body of the document. Instead, we simply want to make the contents of\nthe view element available for use in the page title.</p><p>This unusual behavior can be achieved simply by removing the element from the\nDOM during linking. The directive remains active in spite of its element\nbeing detached, and any interpolations within it will work as expected since\nwatchers are attached to scopes rather than to DOM elements:</p><p>Here we just reflect the text content of the <tt>view-title</tt> element into the\n<tt>viewTitle</tt> variable, so that we can use it within the title element in the\napplication's main template:</p><p>Watching the element's text content is a tricky way to automatically benefit\nfrom Angular's existing interpolation of the body, but performance-concious\napplications will probably want to avoid traversing DOM in a watcher by\nmanually interpolating the text in the element at compile time.</p><section id=\"don-t-repeat-yourself\"><h4>Don't Repeat Yourself</h4><p>Since the \"view title\" is often present inside some visible element on the\npage, we can avoid repetition by extending the directive to also support\nuse as an attribute on an existing element. This is a simple matter of adding\n<tt>A</tt> to the <tt>restrict</tt> key in the directive definition, and then only\nconditionally removing the affected element:</p><p>The view title can then be \"borrowed\" from another element in the view template:</p><p>Since the <tt>view-title</tt> directive is originally encountered by angular inside\nthe <tt>ng-view</tt> directive, references to variables remain relative to the view\nscope even though the title is presented outside of it.</p><p>This technique, along with a related technique for adding metadata elements\nto the document's <tt>head</tt>, is implemented in my AngularJS library\n<a href=\"https://github.com/apparentlymart/angularjs-viewhead\" target=\"_blank\">angularjs-viewhead</a>,\nwhich includes\n<a href=\"http://apparentlymart.github.io/angularjs-viewhead/example/#/\" target=\"_blank\">a working example</a>.</p></section></section><section id=\"route-specific-sidebar\"><h3>Route-specific Sidebar</h3><p>The above technique of using directives to latch on to elements and then\nmove them around in the DOM can be extended to apply to visible elements too.\nImagine for example an app with a sidebar that normally displays fixed content\non each view, but for some views the sidebar switches to show some\nview-specific content, such as some context-sensitive related links.</p><p>Taking a cue from\n<a href=\"https://docs.djangoproject.com/en/dev/topics/templates/\" target=\"_blank\">Django Templates</a>\nand <a href=\"http://jinja.pocoo.org/docs/dev/\" target=\"_blank\">Jinja2</a>, we can support template\n\"blocks\" that are established by the main page template but can be overridden\non a view-by-view basis.</p><p>Here's a basic page skeleton with a \"sidebar\":</p><p>And then here is an example view template defining custom sidebar content:</p><p>These two templates introduce two new directives: <tt>block-insertion</tt>, which\nmarks an element as being a replacable block, and <tt>block-replacement</tt>,\nwhich can be used in a view template to replace the insertion element\nwith the matching key.</p><p>For simplicity we'll have these directives collaborate via a global variable,\nbut in a real implementation it would be better to use something attached to\nthe injector so that multiple applications can coexist on one page. These\ntwo directives are also tightly coupled together for simplicity's sake.</p><p>Much as with the <tt>view-title</tt> case above, Angular's template compiler treats\nthe replacement element as part of the view scope even though it has been moved\nelsewhere in the DOM, allowing variables from the view scope to be used in\nthe replacement template.</p><p>There is\n<a href=\"http://plnkr.co/edit/BlmbRL\" target=\"_blank\">a complete, working example of this technique</a>\nwhich others are invited to build upon.</p><p>This ought to be made more robust before use in a production application. For\nexample, it out to support the destruction of <tt>block-insertion</tt> directives,\nwhich requires retaining a little more state. It would also be nice for the\nblock replacement to support <tt>$animate</tt> to allow transitions between blocks.</p></section><section id=\"conclusion\"><h3>Conclusion</h3><p>Enthusiasts for the alternative <tt>ui-router</tt> implementation of routing often\ncriticize the limitations of the stock <tt>ngRoute</tt>, but with some creative\nuse of directives and scope one can achieve some more advanced capabilities\nwithout switching away wholesale from Angular's standard routing.</p><p>The fact that directives \"own\" an HTML element but are managed within the\nscope tree allows for such elements to be moved arbitrarily around the document\nor removed from the document altogether while still retaining their connection\nto their original declaration context. This creates some powerful possibilities\nand I'm excited to see what other techniques can come from this capability.</p><p>All code snippets within this article are released into the public domain in\nthe hope that they will be useful, but it is presented only as prototype code\nand has no warranty of any kind.</p></section>", "mainImageUrl": "/angularjs-view-specific-sidebars/None", "title": "View-specific Sidebars in AngularJS", "url": "/angularjs-view-specific-sidebars/", "summary": "Sidebars and titles that vary between views in AngularJS", "date": "2014-09-14", "type": "AngularJS"}}, "path": "/:slug/"}