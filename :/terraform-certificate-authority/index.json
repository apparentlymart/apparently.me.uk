{"pageType": "article", "pathParams": {"slug": "terraform-certificate-authority"}, "locals": {"article": {"body": "<p>Modern datacenter security best-practices call for us to use TLS within our\ninfrastructure, as a \"defense in depth\" approach to reducing the impact of\nintrusions. But managing TLS certificates for this usually requires running\nan in-house certificate authority, which can be difficult to set up and\ntedious to run.</p><p>This article shows how <a href=\"https://terraform.io/\" target=\"_blank\">Hashicorp Terraform</a>, a tool normally associated\nwith infrastructure provisioning, can be used to create and manage a small\nin-house certificate authority with minimal hassle. It also shows how such\nan approach might be used with <a href=\"https://vaultproject.io/\" target=\"_blank\">Hashicorp Vault</a> to establish a CA with\nwhich to configure its TLS certificates and PKI backend.</p><section id=\"anatomy-of-a-certificate-authority\"><h3>Anatomy of a Certificate Authority</h3><p><em>Certificate authority</em> most often refers to a company or other organization\nthat issues TLS certificates that are trusted by web browsers for use on\npublic-facing websites. However, for internal uses such as infrastructure\nsecurity it is not usually necessary to have publicly-trusted certificates,\nand so one can run a <em>private</em> certificate authority within a company that\nis trusted only by infrastructure components within that company.</p><p>A certificate authority is essentially a set of certificate-issuing procedures,\nmaking use of a well-protected private key (known only to those who are able\nto issue certificates) along with a <em>root certificate</em> that can be configured\nas trusted by client software that wishes to verify issued certificates.</p><p>The authority produces <em>child certificates</em> that are signed with the\nauthority's private key and usable by servers and clients holding a specific\nother private key. An authority may also create other subordinate CAs, which\ncan themselves issue certificates and establish a <em>chain of trust</em>.</p><p>The sections that follow will describe how to use Terraform to create the\nresources necessary for a CA, and then some procedures for using Terraform to\nissue certificates on behalf of that CA.</p></section><section id=\"why-use-terraform\"><h3>Why use Terraform?</h3><p>Those running a private CA will usually use the <tt>openssl</tt> command line tool\nor some wrapper around it such as <tt>easyrsa</tt>. When running a CA in this manner\nthere are many different (and often cryptic) commands to learn and many small\nfiles to keep track of, which creates a steep learning curve and requires\ncomplex procedures to keep track of the CA state in a secure manner.</p><p>Terraform has built into it <a href=\"https://www.terraform.io/docs/providers/tls/index.html\" target=\"_blank\">a TLS provider</a> that contains the TLS primitives\nnecessary to run a simple certificate authority. Terraform's TLS support is in\nturn based on the crypto libraries that come with\n<a href=\"https://golang.org/\" target=\"_blank\">the Go programming language</a>, which are also used by <a href=\"https://vaultproject.io/\" target=\"_blank\">Hashicorp Vault</a> for\nmuch of its cryptography work.</p><p>Terraform has two characteristics that make it more convenient for this purpose\nthan typical CLI-based tooling: its declarative configuration language\nprovides a straightforward way to describe the certificates and other resources\nrequired, and its \"state\" concept gives us a single artifact that retains\nall of the necessary state for the CA, allowing us to more easily establish\nprocesses for securely storing this data.</p><p>The configuration can safely be stored in a version control repository for easy\ncollaboration.</p><p>It is important to handle the state file with care: an organization\nfollowing the process described in the following sections will create a\nstate file which, if obtained by an attacker, would undermine the entire CA\nby giving that attacker the ability to arbitarily issue trusted certificates.\nThose who run the CA must define processes for how and where the state file\nwill be stored, how it can be obtained by CA operators in order to issue new\ncertificates, etc. It may be desirable to run Terraform only on a specific\ntrusted, hardened host when interacting with the CA, to prevent remnants of\nthe state file from being left on-disk on various different computer systems.</p><p>This article presumes some familiarity with Terraform, and in particular\nfamiliarity with its general workflow.</p></section><section id=\"establishing-the-root-certificate\"><h3>Establishing the Root Certificate</h3><p>A <em>root</em> certificate is one that stands on its own and is not vouched for by\nany other certificate. Unless your CA is subordinate to another (an idea we'll\nexplore more later), your CA will be built around a root certificate that\nmust be explicitly trusted by any systems that will accept the certificates\nissued by your CA.</p><p>Another way to refer to a certificate that is not vouched for by another is\nthe idea of a <em>self-signed</em> certificate. This is what it sounds like: the\ncertificate \"vouches for\" itself, claiming both to own and to be verified by\nthe same private key.</p><p>To produce a self-signed certificate for our CA we must first generate our\nCA's private key, which will then be used to sign the certificate. A Terraform\nconfig file <tt>root.tf</tt> can do this as follows:</p><p>We first generate a private key, and then use that key to produce a self-signed\ncertificate. The content of <tt>subject</tt> doesn't matter that much for an internal\nCA, but it's important to specify <tt>is_ca_certificate</tt> and the <tt>cert_signing</tt>\nallowed use as shown here, or else clients will not accept certificates that\ndescend from this one.</p><p>The <tt>validity_period_hours</tt> argument defines when this certificate will\nexpire. In this example we set this to three years, but you should consider\nyour own context when choosing an appropriate value to use. Any child\ncertificates must expire before the root expires.</p><p>Terraform's <tt>early_renewal_hours</tt> attribute will cause Terraform to produce\na new root certificate at some point before the current one has expired. Here\nwe have set this to one year. Terraform's built-in dependency management will\ncause all issued certificates to be re-created automatically once a replacement\nroot is established, allowing the CA administrators to re-issue them and get\nall systems updated before the original certificates become invalid.</p><p>Running <tt>terraform apply</tt> against this configuration will cause Terraform\nto generate the private key and the certificate and write both of them into\nthe state file. <tt>terraform show</tt> will display all of the attributes of these\nresources, including the <tt>cert_pem</tt> attribute of the self-signed certificate,\nwhose value can be installed on other systems to establish trust of the CA.</p></section><section id=\"issuing-a-certificate\"><h3>Issuing a Certificate</h3><p>The usual workflow for a CA consists of individuals or departments outside of\nthe CA team requesting certificates using <em>certificate signing requests</em>, or\n<em>CSRs</em>.</p><p>A CSR is a machine-readable description of the desired certificate, signed\nby the private key held by the party that will use the certificate. The job\nof the CA is to verify that the CSR is trustworthy and correct, and then issue\na certificate vouching for the given information.</p><p>The teams requesting certificates would likely <em>not</em> be using Terraform, and\nwill probably generate a CSR using some other workflow, such as the following\n<tt>openssl</tt> commands:</p><pre class='terminal'>$ openssl genrsa -out example.com.key 2048\nGenerating RSA private key, 2048 bit long modulus\n.........+++\n.........................................................................+++\ne is 65537 (0x10001)\n\n$ openssl openssl req -new -sha256 -key example.com.key -out example.com.csr\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [AU]:US\nState or Province Name (full name) [Some-State]:CA\nLocality Name (eg, city) []:Pirate Harbor\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:Example, Inc.\nOrganizational Unit Name (eg, section) []:IT Department\nCommon Name (e.g. server FQDN or YOUR name) []:intranet.example.com\nEmail Address []:it@example.com</pre><p>Our hypothetical IT department would send <tt>example.com.csr</tt> (but <em>not</em>\n<tt>example.com.key</tt>) to the CA operators. Those on the CA team would then\ninspect the CSR and see if the details within appear correct and compliant\nwith organizational standards:</p><pre class='terminal'>$ openssl req -text -noout -verify -in csrs/example.com.pem\nverify OK\nCertificate Request:\n    Data:\n        Version: 0 (0x0)\n        Subject: C=US, ST=CA, L=Pirate Harbor, O=Example, Inc., OU=IT Department, CN=intranet.example.com/emailAddress=it@example.com\n        Subject Public Key Info:\n            Public Key Algorithm: rsaEncryption\n                Public-Key: (2048 bit)\n                Modulus:\n                    00:a7:b6:65:d6:c7:e0:02:2e:6a:d2:d4:a3:3f:fc:\n                    bd:1f:85:85:af:8b:1e:35:f7:82:bd:83:b5:31:6b:\n                    4b:62:4d:64:f4:07:cc:2f:c1:fd:c3:8b:47:41:22:\n                    a6:f1:bf:2a:4f:8a:f8:6f:c7:7c:55:b6:d3:03:5d:\n                    e6:1a:25:f2:64:bb:b2:30:d2:cd:ab:d0:4d:be:17:\n                    d6:41:86:20:1c:bf:70:c2:f3:5f:58:fe:d4:49:85:\n                    c7:ae:b3:29:6c:04:1c:44:80:9b:fc:19:24:b1:2d:\n                    ab:6a:9e:d8:99:aa:a9:51:ee:29:02:95:da:b7:38:\n                    98:78:73:37:19:28:e6:dc:e0:94:6f:b9:75:3c:d5:\n                    ee:45:b7:87:b9:39:b8:62:86:0c:fa:71:e2:71:49:\n                    62:04:a5:a6:0b:da:6e:99:90:c4:e3:2b:cb:23:90:\n                    43:5b:d4:f3:fc:3d:66:b8:3f:18:d0:bd:ed:d0:dd:\n                    7d:6f:6e:4f:a6:da:3f:64:a8:5b:fd:18:06:90:34:\n                    96:a4:6c:70:b8:a7:99:e2:be:58:4f:57:8d:11:d8:\n                    f5:1c:0a:9d:17:be:04:d1:33:ed:26:26:b4:e2:c0:\n                    5e:e5:67:91:8c:9f:07:7f:f5:99:71:08:e6:f8:15:\n                    5e:4d:74:6f:9f:c1:92:25:87:fa:44:d5:cb:b2:19:\n                    2d:53\n                Exponent: 65537 (0x10001)\n        Attributes:\n            a0:00\n    Signature Algorithm: sha256WithRSAEncryption\n         11:78:db:dd:da:14:e6:bf:f8:85:d8:d8:5f:7d:e5:69:38:f4:\n         33:fb:d4:d5:09:a6:68:c2:a7:e0:03:56:93:0b:29:78:61:95:\n         76:09:aa:82:6d:5e:44:21:de:57:ce:1f:32:1e:4a:6c:30:0f:\n         18:ac:7b:22:04:e6:a0:55:da:a0:e8:98:9b:d0:62:c1:56:9f:\n         04:1d:6e:e0:e5:11:2d:3f:4e:a5:79:08:60:ee:a7:ba:ed:91:\n         a9:96:6d:23:93:bb:09:d1:01:5b:9e:cd:9e:93:9b:8e:3a:16:\n         a8:7c:f8:e4:36:e9:7f:60:ca:0d:38:df:89:a9:b3:ce:6a:8e:\n         05:95:31:53:69:c7:d6:8c:f9:b4:8a:c1:bc:70:2d:15:93:ce:\n         2d:e4:09:a0:55:30:23:d1:06:23:37:bf:5c:f4:49:f6:dc:44:\n         da:5b:fe:4d:54:16:55:80:d2:c0:65:f6:b1:0e:06:ee:30:4a:\n         e9:48:31:28:13:7f:8d:02:a0:ff:99:48:68:23:5a:68:fd:cf:\n         35:a4:a9:fb:99:28:18:d1:c8:87:79:44:08:a2:07:19:83:f7:\n         a8:e5:1b:62:fe:a7:4e:89:d7:57:79:cb:c1:05:e7:ea:86:28:\n         50:a4:b2:38:0c:97:f1:a0:99:03:3e:dc:12:d2:97:b2:df:e5:\n         3b:d4:45:9b</pre><p>Assuming everything looks good, the CSR file can be placed in a file within\nthe configuration called (for example) <tt>csrs/example.com.pem</tt> and the\ncertificate itself can be issued through another Terraform resource block,\nin <tt>intranet.tf</tt>:</p><p>This time we use the <tt>tls_locally_signed_cert</tt> resource, which combines a\ncertificate request with a CA certificate (and its associated key) in order\nto produce a descendent certificate.</p><p>The <tt>allowed_uses</tt> keyword <tt>server_auth</tt> means that this server can be\npresented by a server to a client, and used by the client to verify the\nserver. This is the appropriate setting for a certificate that will be\nconfigured for a TLS server.</p><p>We set the validity period of the certificate to <em>two</em> years. As noted earlier,\nthis is required to be earlier than the CA certificate expiration, and so one\nmust be careful to set this appropriately if a new certificate is issued toward\nthe end of the life of the root certificate.</p><p>Now we can <tt>apply</tt> to issue the certificate:</p><pre class='terminal'>$ terraform apply\ntls_private_key.root: Refreshing state... (ID: ...)\ntls_self_signed_cert.root: Refreshing state... (ID: ...)\ntls_locally_signed_cert.intranet: Creating...\n  allowed_uses.#:        \"\" =&gt; \"1\"\n  allowed_uses.0:        \"\" =&gt; \"server_auth\"\n  ca_cert_pem:           \"\" =&gt; \"444386791920640878cc460b7aeaddcb715c831f\"\n  ca_key_algorithm:      \"\" =&gt; \"ECDSA\"\n  ca_private_key_pem:    \"\" =&gt; \"5038895240aab6f181a150d1fae9b57689b1483e\"\n  cert_pem:              \"\" =&gt; \"&lt;computed&gt;\"\n  cert_request_pem:      \"\" =&gt; \"b051ed1d744c164461d860e74ff320b1aaf49e87\"\n  early_renewal_hours:   \"\" =&gt; \"8760\"\n  validity_end_time:     \"\" =&gt; \"&lt;computed&gt;\"\n  validity_period_hours: \"\" =&gt; \"17520\"\n  validity_start_time:   \"\" =&gt; \"&lt;computed&gt;\"\ntls_locally_signed_cert.website: Creation complete\n\nApply complete! Resources: 1 added, 0 changed, 1 destroyed.\n\n$ terraform show\n...\ntls_locally_signed_cert.website:\n  id = 135470627697209310048898171923231502097\n  allowed_uses.# = 1\n  allowed_uses.0 = server_auth\n  ca_cert_pem = 444386791920640878cc460b7aeaddcb715c831f\n  ca_key_algorithm = ECDSA\n  ca_private_key_pem = 5038895240aab6f181a150d1fae9b57689b1483e\n  cert_pem = -----BEGIN CERTIFICATE-----\n  MIIDmjCCAvugAwIBAgIQZeqxn+/wwQfrlNBA0PFvETAKBggqhkjOPQQDBDCBwzEL\n  MAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNBMRYwFAYDVQQHEw1QaXJhdGUgSGFyYm9y\n  MRkwFwYDVQQJExA1ODc5IENvdHRvbiBMaW5rMRMwEQYDVQQREwo5NTU1OS0xMjI3\n  MRUwEwYDVQQKEwxFeGFtcGxlLCBJbmMxLDAqBgNVBAsTI0RlcGFydG1lbnQgb2Yg\n  Q2VydGlmaWNhdGUgQXV0aG9yaXR5MRowGAYDVQQDExFFeGFtcGxlIEluYy4gUm9v\n  dDAeFw0xNjA5MTIwMDIxMzdaFw0xODA5MTIwMDIxMzdaMIGBMQswCQYDVQQGEwJV\n  UzELMAkGA1UECBMCQ0ExFjAUBgNVBAcTDVBpcmF0ZSBIYXJib3IxFjAUBgNVBAoT\n  DUV4YW1wbGUsIEluYy4xFjAUBgNVBAsTDUlUIERlcGFydG1lbnQxHTAbBgNVBAMT\n  FGludHJhbmV0LmV4YW1wbGUuY29tMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n  CgKCAQEAp7Zl1sfgAi5q0tSjP/y9H4WFr4seNfeCvYO1MWtLYk1k9AfML8H9w4tH\n  QSKm8b8qT4r4b8d8VbbTA13mGiXyZLuyMNLNq9BNvhfWQYYgHL9wwvNfWP7USYXH\n  rrMpbAQcRICb/BkksS2rap7YmaqpUe4pApXatziYeHM3GSjm3OCUb7l1PNXuRbeH\n  uTm4YoYM+nHicUliBKWmC9pumZDE4yvLI5BDW9Tz/D1muD8Y0L3t0N19b25Ppto/\n  ZKhb/RgGkDSWpGxwuKeZ4r5YT1eNEdj1HAqdF74E0TPtJia04sBe5WeRjJ8Hf/WZ\n  cQjm+BVeTXRvn8GSJYf6RNXLshktUwIDAQABo0YwRDATBgNVHSUEDDAKBggrBgEF\n  BQcDATAMBgNVHRMBAf8EAjAAMB8GA1UdIwQYMBaAFCve2v+DpZZ3Sgrn/pbH8xhi\n  N5DcMAoGCCqGSM49BAMEA4GMADCBiAJCAfBsc8zW82bzpPJac934PpxB+1axwMAF\n  1B8x3ojSePhW6RD4ukld/73bAHmdWRZOlIezqf2XeTQQM9tZZq739MimAkIAq50y\n  xJRdSNXGDbl/aq/ltWwfsv+m/hj16Npi48wAHqefi2VuS6ALjRzgCkH1OwWqxbi4\n  tjNXCtrWsvmiDgz9sI4=\n  -----END CERTIFICATE-----\n\n  cert_request_pem = b051ed1d744c164461d860e74ff320b1aaf49e87\n  early_renewal_hours = 8760\n  validity_end_time = 2018-09-11T17:21:37.024909783-07:00\n  validity_period_hours = 17520\n  validity_start_time = 2016-09-11T17:21:37.024909783-07:00</pre><p>The <tt>cert_pem</tt> value here is what the CA operator would provide to the IT\ndepartment, along with the CA certificate created earlier, so that they can\nconfigure this hypothetical Intranet server.</p></section><section id=\"requesting-certificates-from-within-terraform\"><h3>Requesting Certificates from within Terraform</h3><p>The previous section assumed that the requester of the certificate was\ndistinct from the CA operations team, and presented a workflow supporting that\nsituation. In a smaller team, it's very possible that the CA will be run by\nthe same individuals that are configuring the rest of the infrastructure,\nand in that situation it might be appropriate to request and issue the\ncertificates entirely within Terraform.</p><p>We can use the <tt>tls_cert_request</tt> resource, along with some other resources\nwe've already seen, to make Terraform orchestrate the request/issue process\nwe described above, in a new file <tt>infrastructure.tf</tt>:</p><p>Where before the private key and CSR were created using  subcommands,\nthis time we use Terraform resources to achieve the same result. After a\nsingle <tt>terraform apply</tt>, all of these resources will be created and the\ncertificate's PEM serialization can be obtained from <tt>terraform show</tt>\nas before.</p></section><section id=\"extracting-certificates-to-standalone-files\"><h3>Extracting Certificates to Standalone Files</h3><p>In the previous sections we saw how we can locate the <tt>cert_pem</tt> attribute\non our generated certificates in order to obtain the PEM-encoded certificate\ncontents.</p><p>Most software expects to be provided keys and certificates each in their\nown separate on-disk file. It would be convenient to automatically extract\nthese values into such files, and that is relatively easy to achieve since\nthe Terraform state file is JSON-encoded and easy to consume from scripts.\nAs part of the prototyping for this article, I wrote\n<a href=\"https://gist.github.com/apparentlymart/0b136b4094cf7ef1919b39648ddd31c6\" target=\"_blank\">a Python script to extract the certificates</a>, creating a directory for\neach distinct certificate name and placing files in here for the issued cert\nand the CA cert respectively.</p></section><section id=\"setting-up-a-vault-server-with-a-tls-certificate\"><h3>Setting up a Vault server with a TLS certificate</h3><p><a href=\"https://vaultproject.io/\" target=\"_blank\">Hashicorp Vault</a> has been generally praised for striking a good compromise\nbetween security and usability. For many situations, it will do the right thing\n\"out of the box\", lowering the barrier to having reasonably-secure handling of\nsecrets within network applications.</p><p>However, one big upset to this ease of getting started is the chicken-and-egg\nproblem of needing to establish enough certificate infrastructure to issue\na certificate for the Vault server itself to use, before there's a Vault server\nin which to store or generate the necessary secrets.</p><p>Through a Terraform config like our <tt>infrastructure.tf</tt> example above, we can\nquickly produce and issue a server certificate and associated private key\nfor Vault to use, and configure Vault clients to trust our CA certificate.\nThe common name of this certificate must be the hostname at which clients\nwill access the Vault server.</p><p>The <tt>listener</tt> section of a Vault configuration file is where we will\nspecify the paths to files containing the Vault server's private key and\ncertificate:</p><p>Clients connecting to the Vault server will also need to trust the root\nCA certificate. How this is done unfortunately varies depending on the\noperating system; on Linux systems one of the following files is consulted for\nlists of trusted root CA certificates in PEM format:</p><ul><li><p><tt>/etc/ssl/certs/ca-certificates.crt</tt></p></li><li><p><tt>/etc/pki/tls/certs/ca-bundle.crt</tt></p></li><li><p><tt>/etc/ssl/ca-bundle.pem</tt></p></li><li><p><tt>/etc/pki/tls/cacert.pem</tt></p></li></ul><p>Alternatively, the <tt>VAULT_CACERT</tt> environment variable can be set on the\nVault process to explicitly specify the CA certificate that Vault should\nexpect.</p></section><section id=\"issuing-certificates-automatically-with-vault\"><h3>Issuing Certificates Automatically with Vault</h3><p>Alongside the use of TLS for client-to-server communication, Vault also has\n<a href=\"https://www.vaultproject.io/docs/secrets/pki/index.html\" target=\"_blank\">a secret backend that allows it to automatically issue TLS certificates</a>\nusing the same underlying cryptography code that Terraform uses to implement\nthe resources we've seen so far.</p><p>This Vault feature can be used to automate the issuing of certificates to\nTLS clients and servers, so it can be set up once and then run largely without\noperator intervention as new applications join and leave the environment.\nThis can be an effective way to enable mutual authentication between TLS\nclients and servers within a datacenter, which can be a step towards a\n\"zero trust\" architecture.</p><p>The recommended way to use this feature is to establish a root CA, as we've\ndone earlier in this article, and then use it to establish an\n<em>intermediate CA</em> within Vault. This means that Vault maintains its own CA\nthat is subordinate to our root CA.</p><p>We can adapt our earlier <tt>infrastructure.tf</tt> configuration to create a new\nsigning certificate for Vault to use, but first we need to ask Vault to\ngenerate a certificate signing request. At this step, Vault generates a\nprivate key but does not expose it to the operator:</p><pre class='terminal'>$ vault mount pki\nSuccessfully mounted 'pki' at 'pki'!\n$ vault write /pki/intermediate/generate/internal common_name=vault-ca.example.com exclude_ca_from_sans=true\nKey Value\ncsr -----BEGIN CERTIFICATE REQUEST-----\nMIICljCCAX4CAQAwHzEdMBsGA1UEAxMUdmF1bHQtY2EuZXhhbXBsZS5jb20wggEi\nMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQC7OjTpRfItq455zCKit3F98Wra\nvtSq0LjpQWMOBHQzG3OMrqdgAPlBLl38+8ey1j1f+GI15B5NeQhOwe2WqjlwFpzN\nxUcZPq40hghDMHycDAuClkDgv5J8vnTmA/mc8OdrwAlU9lHz0YR1hkq2jsgTRW1G\n9b3G3D0JvhVpCtLUj7CU6i8IiMeBWt/xI2uh4SNQL44jB5mVxV5mEBZ/ldhnC4kU\nhFJoIdVO/AGzKQrm1horssditPVH0KaMia72LGeb/OEe93b46AjBy2PX2mFQJssV\npWvAvvo7XaJJ/Ox/mA717j4blTbx0Hkp6j2g7xGJJXQOmbWgoJ8OsUylSArVAgMB\nAAGgMjAwBgkqhkiG9w0BCQ4xIzAhMB8GA1UdEQQYMBaCFHZhdWx0LWNhLmV4YW1w\nbGUuY29tMA0GCSqGSIb3DQEBCwUAA4IBAQCvhAgfm9MlYFRlm/9FcWRitgxvOgkJ\n95qNByFshsrhRHoyWWpZjNPIqkzWEFTAMsTVV18TkEOSmZZgcmqi3TWg61EKLoTm\nLRLv1bAa+xUv6i55LZOkllgCKfWGxOynFBHpn2KvwfR9A7N5lEM8FPOhY+WtxpWE\nG7FUhZN1wyqpfdWIxdWgyi9djpuBBEGAsXWKKvMX7U3MDKYoBJ+PXzTtPnXChL8Y\nCbsrURvpKLsnM+zKPl991P9d9ubXsXl0yeOSoOglNd8lN/CeHMueXAqyyQS+lLV+\ndrde2OSezqo/bBwFwtm8sw+kwZWuc+uLHm7He1kBfYxg2/Bpq38b6NBo\n-----END CERTIFICATE REQUEST-----</pre><p>This CSR block (with the <tt>csr</tt> key name removed from the first line) can\nbe placed at <tt>csrs/vault.pem</tt> and then we can create <tt>vault.tf</tt> to\nissue the certificate:</p><p>This time we again set <tt>is_ca_certificate</tt> and allow <tt>cert_signing</tt>, since\nthis certificate will be used by Vault to issue further certificates.</p><p>After <tt>terraform apply</tt>, we can extract the generated certificate, place\nit in a file called <tt>vault.crt</tt> and complete setup by loading it into\nVault:</p><pre class='terminal'>$ vault write /pki/intermediate/set-signed -certificate=@vault.crt</pre><p>See the Vault documentation on the PKI auth backend for more information\non how this can be used to issue short-lived server and client certificates\n(and associated private keys) for applications to use.</p></section><section id=\"terraform-ca-caveats\"><h3>Terraform CA Caveats</h3><p>In addition to the earlier warning about the need to securely store the\nTerraform state containing the CA secrets, there are some other caveats to\nkeep in mind when using Terraform as the basis of a certificate authority.</p><p>Certificates issued by Terraform will not specify the location of a\n<em>certificate revocation list</em>, meaning that there is no ready mechanism to\ncancel any issued certificates in the event that they are compromised. It is\ntherefore ideal to use Terraform only for the most foundational parts of the\nCA, which can be protected most carefully, and then use it to provision a\nsystem like Vault's PKI secret backend described above in order to\ndelegate the more routine issuing of certificates to a more specialized tool.\nIn this case, Terraform is just used to solve the chicken-and-egg problem in\nits initial configuration.</p><p>Additionally, a Terraform configuration with hundreds or thousands of resources\nis currently not especially performant, and will result in an oversize state\nfile that may be hard to transmit and store securely. This is a further\nreason to limit Terraform's role to the initial setup, and delegate broader\nmanagement tasks to a more appropriate system.</p></section><section id=\"conclusion\"><h3>Conclusion</h3><p>In this article we've seen how Terraform can be used to establish and operate\na small certificate authority within an organization, and explored some\npractical situations where such a solution may be helpful.</p><p>As always with security and cryptography concerns, context is important and\nthere is no \"one size fits all\" solution. Where possible I have tried to\nmake my assumptions explicit, but when considering the techniques\nwithin this article, be sure to consider any regulatory or organizational\nconstraints that may affect the applicability of this technique within your\nparticular environment.</p></section>", "mainImageUrl": "/terraform-certificate-authority/None", "title": "Running a TLS CA with Terraform", "url": "/terraform-certificate-authority/", "summary": "Using Hashicorp Terraform to build and run a small, in-house certificate authority", "date": "2016-09-11", "type": "Security"}}, "path": "/:slug/"}